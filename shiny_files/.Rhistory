#paths from above arguments
disk_path <- file.path(tif_top_dir,version_name)
all_folders_name <- list.files(disk_path)
all_folders_dir <- file.path(disk_path,all_folders_name)
all_folders_dir_processed <- list()
for(folder_dir in all_folders_dir){
all_folders_dir_processed <- c(all_folders_dir_processed,file.path(folder_dir, list.files(folder_dir)[1]))
}
all_folders_dir_processed <- unlist(all_folders_dir_processed)#convert from list to character vector
dir_path <- all_folders_dir_processed[folder_idx]#'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
folder_name <- all_folders_name[folder_idx]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed <- TRUE)[[1]][1]#Alclat2_stem. fixed<-TRUE to avoid interpreting "." as a regex
if(has_processed==TRUE){
img_folder_rel <- file.path(img_dir,"Done", "Processed")
}else{
img_folder_rel <- file.path(img_dir,"ImagesNotYetProcessed")
}
img_folder <- file.path(img_folder_rel,folder_name)
if(use_predict_tif|!has_processed){#use predict.tif when use_predict_tif is set to True or doesn't have true.tif
input_tif_name <- 'predict.tif'
input_tif_path <- file.path(dir_path,input_tif_name)
}else{
tiff_files <- list.files(img_folder, pattern = '.tif', full.names=TRUE)
match <- FALSE
#With full.names=TRUE then list.files returns the full path, so file.info can find the files and report back okay
#make sure have tif file in there for the processed ones
if(length(tiff_files)>0){
#To get the most recent modified tiff file
#choose the most recent modified one if there are multiple of them
#first order the files by modified time.
#And start from the most recently modified one, see if the filename includes "mask of result of substack".
#if there's one match, break the loop.
tiff_paths_info <- file.info(tiff_files)#info dataframe on tif files (including modified time)
tiff_paths_info <- cbind(tiff_paths_info,tiff_files)#add tif file path to the df
tiff_paths_info <- tiff_paths_info[with(tiff_paths_info, order(as.POSIXct(mtime),decreasing=TRUE)), ]#ordered by latest -> oldest
for(up_2_date_tiff in tiff_paths_info$tiff_files){
#find files with following regex
idx_pat <- 'mask of result of substack'
cand_match <- str_extract(tolower(up_2_date_tiff),idx_pat)
if(!is.na(cand_match)){
match <- TRUE
break
}
}
}else{
stop(paste("Error: no tif file in",img_folder))
}
if(!match){
stop("Error: no match for true tif file")
}else{
input_tif_path <- up_2_date_tiff
}
}
print(paste("tif name:",input_tif_path))
# #[Diane]
# img_dir <- '../../Done/Processed'
# dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
# dir_split <- strsplit(dir_path,"/")[[1]]
# version_name <- dir_split[length(dir_split)-2]
# folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
# folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
# output_dir <- 'F:/emb_data'
# true_tif_name <-
#
# #use the below arguments and save different csv file
# use_true_tif <- TRUE #(TRUE):use true labels tif . (FALSE): use predict.tif
# #default is to plot tp emb.
# plot_fn <- TRUE #(TRUE):plot fn emb. from false_positive_index.txt
# plot_fp <- FALSE
#Read Data from TIFF file
library(bioimagetools)
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
# #,native =TRUE.
# #native
# # determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting) (i.e. row, col for points that are nonzero?).
# #problem: Error: cannot allocate vector of size 6.5 Gb when use_predict_tif is FALSE
# if(!require("rtiff")){
#   install.packages("rtiff")
# }
# library(rtiff)
# pred_tiff <- readTiff(file.path(input_tif_path),  reduce = 0.8, pixmap = TRUE)
# # reduce
# #pixmap rescales the values to [0..1]. If you want the raw values from the file, set pixmap=FALSE to get a list of r, g, and b values, unscaled
num_imgs <- dim(pred_tiff)[3]
row_num  <- dim(pred_tiff)[1]
col_num  <- dim(pred_tiff)[2]
#get the embolism time data.
all_files <- list.files(img_folder, pattern = '.png')
if(length(all_files)<0){#try jpg instead
all_files <- list.files(img_folder, pattern = '.jpg')
}else{
stop("Error: Image files aren't png or jpg")
}
#Read Data from TIFF file
library(bioimagetools)
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
remove(pred_tiff)
#Read Data from TIFF file
library(bioimagetools)
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
# #,native =TRUE.
# #native
# # determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting) (i.e. row, col for points that are nonzero?).
# #problem: Error: cannot allocate vector of size 6.5 Gb when use_predict_tif is FALSE
# if(!require("rtiff")){
#   install.packages("rtiff")
# }
# library(rtiff)
# pred_tiff <- readTiff(file.path(input_tif_path),  reduce = 0.8, pixmap = TRUE)
# # reduce
# #pixmap rescales the values to [0..1]. If you want the raw values from the file, set pixmap=FALSE to get a list of r, g, and b values, unscaled
num_imgs <- dim(pred_tiff)[3]
row_num  <- dim(pred_tiff)[1]
col_num  <- dim(pred_tiff)[2]
#get the embolism time data.
all_files <- list.files(img_folder, pattern = '.png')
if(length(all_files)==0){#try jpg instead
all_files <- list.files(img_folder, pattern = '.jpg')
}
if(length(all_files)==0){
stop("Error: Image files aren't png or jpg")
}
get_img_idx_from_txt <- function(txt_path,has_header=FALSE,plus_one=TRUE){
# inputs:
#   txt_path: path file for txt to be read
#   has_header: if txt's first row is header --> True, else --> False
#   plus_one: set to True if img_idx needed to be added by 1 (happens when change from 0-starting index (python) to 1-starting index(R))
#get the idx name
img_idx <- as.vector(unlist(read.csv(txt_path,header = has_header)))
if(plus_one){
#get the idx name correct one in R by adding 1 (cuz python starts wit 0)
img_idx <- img_idx+1
}
return(img_idx)
}
tp_img_idx <- get_img_idx_num_from_txt(file.path(dir_path,'true_positive_index.txt'))
get_img_idx_from_txt <- function(txt_path,has_header=FALSE,plus_one=TRUE){
# inputs:
#   txt_path: path file for txt to be read
#   has_header: if txt's first row is header --> True, else --> False
#   plus_one: set to True if img_idx needed to be added by 1 (happens when change from 0-starting index (python) to 1-starting index(R))
#get the idx name
img_idx <- as.vector(unlist(read.csv(txt_path,header = has_header)))
if(plus_one){
#get the idx name correct one in R by adding 1 (cuz python starts wit 0)
img_idx <- img_idx+1
}
return(img_idx)
}
tp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'true_positive_index.txt'))
emb_img_idx_plot <-tp_img_idx #image index to plot
#concate emb_img_idx_plot with fn_img_idx and fp_img_idx if their arguments(plot_fn,plot_fp) are set to TRUE
if(plot_fn){
fn_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_negative_index.txt'))
emb_img_idx_plot <-rbind(emb_img_idx_plot,fn_img_idx)
}
if(plot_fp){
fp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_positive_index.txt'))
emb_img_idx_plot <-rbind(emb_img_idx_plot,fp_img_idx)
}
emb_img_idx_plot <- sort(emb_img_idx_plot) #sort in increasing order
emb_num_plot <- length(emb_img_idx_plot) #total number of embolism to plot (img level)
tp_img_idx
emb_img_idx_plot
tp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'true_positive_index.txt'))
emb_img_idx_plot <-tp_img_idx #image index to plot
a <-c(emb_img_idx_plot,fn_img_idx)
a
get_img_idx_from_txt <- function(txt_path,has_header=FALSE,plus_one=TRUE){
# inputs:
#   txt_path: path file for txt to be read
#   has_header: if txt's first row is header --> True, else --> False
#   plus_one: set to True if img_idx needed to be added by 1 (happens when change from 0-starting index (python) to 1-starting index(R))
#get the idx name
img_idx <- as.vector(unlist(read.csv(txt_path,header = has_header)))
if(plus_one){
#get the idx name correct one in R by adding 1 (cuz python starts wit 0)
img_idx <- img_idx+1
}
return(img_idx)
}
tp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'true_positive_index.txt'))
emb_img_idx_plot <-tp_img_idx #image index to plot
#concate emb_img_idx_plot with fn_img_idx and fp_img_idx if their arguments(plot_fn,plot_fp) are set to TRUE
if(plot_fn){
fn_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_negative_index.txt'))
emb_img_idx_plot <-c(emb_img_idx_plot,fn_img_idx)
}
if(plot_fp){
fp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_positive_index.txt'))
emb_img_idx_plot <-c(emb_img_idx_plot,fp_img_idx)
}
emb_img_idx_plot <- sort(emb_img_idx_plot) #sort in increasing order
emb_num_plot <- length(emb_img_idx_plot) #total number of embolism to plot (img level)
#Read Data from TIFF file
library(bioimagetools)
read_input_tif <- function(input_tif_path){
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
# #,native =TRUE.
# #native
# # determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting) (i.e. row, col for points that are nonzero?).
# #problem: Error: cannot allocate vector of size 6.5 Gb when use_predict_tif is FALSE
# if(!require("rtiff")){
#   install.packages("rtiff")
# }
# library(rtiff)
# pred_tiff <- readTiff(file.path(input_tif_path),  reduce = 0.8, pixmap = TRUE)
# # reduce
# #pixmap rescales the values to [0..1]. If you want the raw values from the file, set pixmap=FALSE to get a list of r, g, and b values, unscaled
num_imgs <- dim(pred_tiff)[3]
row_num  <- dim(pred_tiff)[1]
col_num  <- dim(pred_tiff)[2]
return(list(num_imgs,row_num,col_num))
}
tmp <- read_input_tif(input_tif_path)
memory.limit()
round(memory.limit(),2)
memory.size()
require("reticulate")
source_python("pickle_reader.py")
pickle_data <-  pd.read_pickle("F:\emb_data\v11\Alclat2_stem\shinydata.pkl")
pickle_data <-  pd.read_pickle("F:/emb_data/v11/Alclat2_stem/shinydata.pkl")
require("reticulate")
pickle_data <-  pd.read_pickle("F:/emb_data/v11/Alclat2_stem/shinydata.pkl")
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file("C:/tsa/dataset.pickle")
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_dir,version_name,folder_name_short,'shinydata.pkl'))
pickle_data
pickle_data <- read_pickle_file(file.path(output_dir,version_name,folder_name_short,'shinydata.pkl'))
pickle_data
pickle_data$num_imgs
library(stringr)#for regex
img_dir <- file.path('..','..')
has_processed <- TRUE
tif_top_dir <- 'F:/server_output/processed'
version_name <- 'v11'
output_dir <- 'F:/emb_data'
folder_idx <- 1#starts with 1 in R
#use the below arguments and save different csv file
use_predict_tif <- TRUE #(False):use true labels tif . (True or has_processed<-False): use predict.tif
#default is to plot tp emb.
plot_fn <- TRUE #(TRUE):plot fn emb. from false_positive_index.txt
plot_fp <- FALSE
#paths from above arguments
disk_path <- file.path(tif_top_dir,version_name)
all_folders_name <- list.files(disk_path)
all_folders_dir <- file.path(disk_path,all_folders_name)
all_folders_dir_processed <- list()
for(folder_dir in all_folders_dir){
all_folders_dir_processed <- c(all_folders_dir_processed,file.path(folder_dir, list.files(folder_dir)[1]))
}
all_folders_dir_processed <- unlist(all_folders_dir_processed)#convert from list to character vector
dir_path <- all_folders_dir_processed[folder_idx]#'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
folder_name <- all_folders_name[folder_idx]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed <- TRUE)[[1]][1]#Alclat2_stem. fixed<-TRUE to avoid interpreting "." as a regex
if(has_processed==TRUE){
img_folder_rel <- file.path(img_dir,"Done", "Processed")
}else{
img_folder_rel <- file.path(img_dir,"ImagesNotYetProcessed")
}
img_folder <- file.path(img_folder_rel,folder_name)
if(use_predict_tif|!has_processed){#use predict.tif when use_predict_tif is set to True or doesn't have true.tif
input_tif_name <- 'predict.tif'
input_tif_path <- file.path(dir_path,input_tif_name)
}else{
tiff_files <- list.files(img_folder, pattern = '.tif', full.names=TRUE)
match <- FALSE
#With full.names=TRUE then list.files returns the full path, so file.info can find the files and report back okay
#make sure have tif file in there for the processed ones
if(length(tiff_files)>0){
#To get the most recent modified tiff file
#choose the most recent modified one if there are multiple of them
#first order the files by modified time.
#And start from the most recently modified one, see if the filename includes "mask of result of substack".
#if there's one match, break the loop.
tiff_paths_info <- file.info(tiff_files)#info dataframe on tif files (including modified time)
tiff_paths_info <- cbind(tiff_paths_info,tiff_files)#add tif file path to the df
tiff_paths_info <- tiff_paths_info[with(tiff_paths_info, order(as.POSIXct(mtime),decreasing=TRUE)), ]#ordered by latest -> oldest
for(up_2_date_tiff in tiff_paths_info$tiff_files){
#find files with following regex
idx_pat <- 'mask of result of substack'
cand_match <- str_extract(tolower(up_2_date_tiff),idx_pat)
if(!is.na(cand_match)){
match <- TRUE
break
}
}
}else{
stop(paste("Error: no tif file in",img_folder))
}
if(!match){
stop("Error: no match for true tif file")
}else{
input_tif_path <- up_2_date_tiff
}
}
print(paste("tif name:",input_tif_path))
# #[Diane]
# img_dir <- '../../Done/Processed'
# dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
# dir_split <- strsplit(dir_path,"/")[[1]]
# version_name <- dir_split[length(dir_split)-2]
# folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
# folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
# output_dir <- 'F:/emb_data'
# true_tif_name <-
#
# #use the below arguments and save different csv file
# use_true_tif <- TRUE #(TRUE):use true labels tif . (FALSE): use predict.tif
# #default is to plot tp emb.
# plot_fn <- TRUE #(TRUE):plot fn emb. from false_positive_index.txt
# plot_fp <- FALSE
#Read Data from TIFF file
library(bioimagetools)
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
# #,native =TRUE.
# #native
# # determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting) (i.e. row, col for points that are nonzero?).
# #problem: Error: cannot allocate vector of size 6.5 Gb when use_predict_tif is FALSE, doesn't help even when put it into a function
# # blow doesn't solve memory allocation problem
# if(!require("rtiff")){
#   install.packages("rtiff")
# }
# library(rtiff)
# pred_tiff <- readTiff(file.path(input_tif_path),  reduce = 0.8, pixmap = TRUE)
# # reduce
# #pixmap rescales the values to [0..1]. If you want the raw values from the file, set pixmap=FALSE to get a list of r, g, and b values, unscaled
num_imgs <- dim(pred_tiff)[3]
row_num  <- dim(pred_tiff)[1]
col_num  <- dim(pred_tiff)[2]
#get the embolism time data.
all_files <- list.files(img_folder, pattern = '.png')
if(length(all_files)==0){#try jpg instead
all_files <- list.files(img_folder, pattern = '.jpg')
}
if(length(all_files)==0){
stop("Error: Image files aren't png or jpg")
}
plot(pred_tiff[,,125])
a <- pred_tiff[,,125]
library(EBImage)
a_med <- medianFilter
a_med <- medianFilter(a,5)
plot(a_med)
View(a)
a_med <- medianFilter(a,3)
plot(a_med)
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
ouput_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
#num_imgs <- pickle_data$num_imgs #unused in shiny app part
row_num <- pickle_data$row_num
col_num <- pickle_data$col_num
date_time_list <- pickle_data$date_time_list
diff_time_list_int <- pickle_data$diff_time_list_int
embolism_table <- pickle_data$embolism_table
plot_mat_all <- pickle_data$plot_mat_all
plot_tiff <- pickle_data$plot_tiff
#load(file.path(output_dir,version_name,folder_name_short,'shinydata.RData'))
css <- "#table{
background: yellow;
font-size: 12px;
}"
library(bioimagetools)
library(dplyr)
library(Matrix)
library(plotly)
polygon_vertices <- read.csv(file.path(output_folder,'polygon_vertices_df.csv'),row.names = 1) #from points_boundary.ipynb
embo_table_alpha <- embolism_table[embolism_table$number_emb %in% unique(polygon_vertices$Z),]
unique(polygon_vertices$Z)
embolism_table$number_emb
View(embolism_table)
class(embolism_table)
colnames(embolism_table)
embolism_table+df <- reticulate::py$embolism_table
print(embolism_table)
e_df <- data.frame(embolism_table)
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
#num_imgs <- pickle_data$num_imgs #unused in shiny app part
row_num <- pickle_data$row_num
col_num <- pickle_data$col_num
date_time_list <- pickle_data$date_time_list
diff_time_list_int <- pickle_data$diff_time_list_int
embolism_table <- pickle_data$embolism_table
plot_mat_all <- pickle_data$plot_mat_all
plot_tiff <- pickle_data$plot_tiff
#load(file.path(output_dir,version_name,folder_name_short,'shinydata.RData'))
css <- "#table{
background: yellow;
font-size: 12px;
}"
library(bioimagetools)
library(dplyr)
library(Matrix)
library(plotly)
polygon_vertices <- read.csv(file.path(output_folder,'polygon_vertices_df.csv'),row.names = 1) #from points_boundary.ipynb
embo_table_alpha <- embolism_table[embolism_table$number_emb %in% unique(polygon_vertices$Z),]
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file(file.path(output_folder,'shinydata.pkl'))#from get_data.py
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
img_dir <- '../../Done/Processed'
dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
dir_split <- strsplit(dir_path,"/")[[1]]
version_name <- dir_split[length(dir_split)-2]
folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
output_dir <- 'F:/emb_data'
output_folder <- 'F:/emb_data/v11/Alclat2_stem/true_tif_has_fn_no_fp'
#TODO: input_tif might be different dim than before
require("reticulate")
source_python("pickle_reader.py")
pip install rpy2
install.packages(rpy2)
install.packages("rpy2")
