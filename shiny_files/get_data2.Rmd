---
title: "DataGet"
author: "Dingyi Fang"
date: "4/14/2020"
output: html_document
---
#Decide paths from user-specified arguments
```{r path}
library(stringr)#for regex

img_dir <- file.path('..','..')
has_processed <- TRUE
tif_top_dir <- 'F:/server_output/processed'
version_name <- 'v11'
output_dir <- 'F:/emb_data'
folder_idx <- 1#starts with 1 in R

#use the below arguments and save different csv file
use_predict_tif <- TRUE #(False):use true labels tif . (True or has_processed<-False): use predict.tif 
#default is to plot tp emb.
plot_fn <- FALSE #(TRUE):plot fn emb. from false_positive_index.txt 
plot_fp <- FALSE 


#paths from above arguments
disk_path <- file.path(tif_top_dir,version_name)
all_folders_name <- list.files(disk_path)

all_folders_dir <- file.path(disk_path,all_folders_name)
all_folders_dir_processed <- list()
for(folder_dir in all_folders_dir){
  all_folders_dir_processed <- c(all_folders_dir_processed,file.path(folder_dir, list.files(folder_dir)[1]))
}
all_folders_dir_processed <- unlist(all_folders_dir_processed)#convert from list to character vector

dir_path <- all_folders_dir_processed[folder_idx]#'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
folder_name <- all_folders_name[folder_idx]#Alclat2_stem.DONEGOOD.HANNAH.9.26
folder_name_short <- strsplit(folder_name,".", fixed <- TRUE)[[1]][1]#Alclat2_stem. fixed<-TRUE to avoid interpreting "." as a regex

if(has_processed==TRUE){
  img_folder_rel <- file.path(img_dir,"Done", "Processed")
}else{
  img_folder_rel <- file.path(img_dir,"ImagesNotYetProcessed")
}

img_folder <- file.path(img_folder_rel,folder_name)

if(use_predict_tif|!has_processed){#use predict.tif when use_predict_tif is set to True or doesn't have true.tif
   input_tif_name <- 'predict.tif'
   input_tif_path <- file.path(dir_path,input_tif_name)
}else{
    tiff_files <- list.files(img_folder, pattern = '.tif', full.names=TRUE)
    match <- FALSE
    #With full.names=TRUE then list.files returns the full path, so file.info can find the files and report back okay
    #make sure have tif file in there for the processed ones
    if(length(tiff_files)>0){
      #To get the most recent modified tiff file
        #choose the most recent modified one if there are multiple of them
        
        #first order the files by modified time. 
        #And start from the most recently modified one, see if the filename includes "mask of result of substack".
        #if there's one match, break the loop.
        tiff_paths_info <- file.info(tiff_files)#info dataframe on tif files (including modified time)
        tiff_paths_info <- cbind(tiff_paths_info,tiff_files)#add tif file path to the df
        tiff_paths_info <- tiff_paths_info[with(tiff_paths_info, order(as.POSIXct(mtime),decreasing=TRUE)), ]#ordered by latest -> oldest
        for(up_2_date_tiff in tiff_paths_info$tiff_files){
          #find files with following regex
            idx_pat <- 'mask of result of substack'
            cand_match <- str_extract(tolower(up_2_date_tiff),idx_pat)
            if(!is.na(cand_match)){
              match <- TRUE
                break
            }
                
        }
            
    }else{
      stop(paste("Error: no tif file in",img_folder))
    }
        
    if(!match){
      stop("Error: no match for true tif file")
    }else{
      input_tif_path <- up_2_date_tiff
    }
        
}
print(paste("tif name:",input_tif_path))


# #[Diane]
# img_dir <- '../../Done/Processed'
# dir_path <- 'F:/server_output/processed/v11/Alclat2_stem.DONEGOOD.HANNAH.9.26/v11.0_0_1_900'
# dir_split <- strsplit(dir_path,"/")[[1]]
# version_name <- dir_split[length(dir_split)-2]
# folder_name <- dir_split[length(dir_split)-1]#Alclat2_stem.DONEGOOD.HANNAH.9.26
# folder_name_short <- strsplit(folder_name,".", fixed = TRUE)[[1]][1]#Alclat2_stem. fixed=TRUE to avoid interpreting "." as a regex
# output_dir <- 'F:/emb_data'
# true_tif_name <- 
# 
# #use the below arguments and save different csv file
# use_true_tif <- TRUE #(TRUE):use true labels tif . (FALSE): use predict.tif 
# #default is to plot tp emb.
# plot_fn <- TRUE #(TRUE):plot fn emb. from false_positive_index.txt 
# plot_fp <- FALSE
```
#Read File Part
Memory limit error for pred_tiff when use_predict_tif is FALSE--> switch to get_data.py
```{r read_tif}
#Read Data from TIFF file
library(bioimagetools)
pred_tiff = bioimagetools::readTIF(file.path(input_tif_path))
# 1: background, 0: embolism
# #,native =TRUE. 
# #native
# # determines the image representation - if FALSE (the default) then the result is an array, if TRUE then the result is a native raster representation (suitable for plotting) (i.e. row, col for points that are nonzero?).
# #problem: Error: cannot allocate vector of size 6.5 Gb when use_predict_tif is FALSE, doesn't help even when put it into a function

# # blow doesn't solve memory allocation problem
# if(!require("rtiff")){
#   install.packages("rtiff")
# }
# library(rtiff)
# pred_tiff <- readTiff(file.path(input_tif_path),  reduce = 0.8, pixmap = TRUE)
# # reduce
# #pixmap rescales the values to [0..1]. If you want the raw values from the file, set pixmap=FALSE to get a list of r, g, and b values, unscaled

num_imgs <- dim(pred_tiff)[3]
row_num  <- dim(pred_tiff)[1]
col_num  <- dim(pred_tiff)[2] 
#get the embolism time data.
all_files <- list.files(img_folder, pattern = '.png')
if(length(all_files)==0){#try jpg instead
  all_files <- list.files(img_folder, pattern = '.jpg')
}
if(length(all_files)==0){
  stop("Error: Image files aren't png or jpg")
}
```

#get emb_img_idx_plot (the image index that have to be plotted) and emb_num_plot (the total number of images to be plotted)

```{r emb_img_idx_plot}
get_img_idx_from_txt <- function(txt_path,has_header=FALSE,plus_one=TRUE){
  # inputs:
  #   txt_path: path file for txt to be read
  #   has_header: if txt's first row is header --> True, else --> False
  #   plus_one: set to True if img_idx needed to be added by 1 (happens when change from 0-starting index (python) to 1-starting index(R))
  
  #get the idx name
  img_idx <- as.vector(unlist(read.csv(txt_path,header = has_header)))
  if(plus_one){
    #get the idx name correct one in R by adding 1 (cuz python starts wit 0)
    img_idx <- img_idx+1
  }
  
  return(img_idx)
}


tp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'true_positive_index.txt'))

emb_img_idx_plot <-tp_img_idx #image index to plot

#concate emb_img_idx_plot with fn_img_idx and fp_img_idx if their arguments(plot_fn,plot_fp) are set to TRUE
if(plot_fn){
  fn_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_negative_index.txt'))
  emb_img_idx_plot <-c(emb_img_idx_plot,fn_img_idx)
}
if(plot_fp){
  fp_img_idx <- get_img_idx_from_txt(file.path(dir_path,'false_positive_index.txt'))
  emb_img_idx_plot <-c(emb_img_idx_plot,fp_img_idx)
}

emb_img_idx_plot <- sort(emb_img_idx_plot) #sort in increasing order
emb_num_plot <- length(emb_img_idx_plot) #total number of embolism to plot (img level)

```

codes below: replace 'tp_num' by 'emb_num_plot' and 'tp_img_idx' by 'emb_img_idx_plot'

#Processing the tiff into matrix pixel value
```{r tif_to_mat}
#column data for X and row data for Y
num = 1
plot_mat_all <- data.frame()#3 cols: row,col,Z
for (j in emb_img_idx_plot) {
 plot_mat_j <- which(abs(pred_tiff[,,j]-1)!=0 , arr.ind = T)
 plot_mat_j <- data.frame(plot_mat_j)
 plot_mat_j$Z <- num
 plot_mat_all <- rbind(plot_mat_all,plot_mat_j)
 num <- num+ 1
}

image(pred_tiff[,,emb_img_idx_plot[0]], useRaster=TRUE, axes=FALSE)#just to take a look
```
#Processing the time list
```{r time_list}
#get the photo taken time
date_time_list = NULL
#initial the start time 
for (file in all_files) {
  time_str = unlist(strsplit(file, split = '.png'))
  #put all year month day in formate
  Year = substr(time_str,1,4)
  Month = substr(time_str,5,6)
  Day = substr(time_str,7,8)
  YMD = paste(Year,Month,Day,sep = '-')
  Hour = substr(time_str,10,11)
  Minute = substr(time_str,12,13)
  Secs = substr(time_str,14,15)
  HMS = paste(Hour,Minute,Secs, sep = ':')
  date_time = paste(YMD,HMS,sep = ' ')
  date_time_list = c(date_time_list,date_time)
}
#compute the relative time
date_time_list = date_time_list[1:num_imgs+1]
start_time = date_time_list[1]
diff_time_list = NULL
for (date_time in date_time_list) {
  diff_time = difftime(date_time,start_time, units = 'mins')
  diff_time_list = c(diff_time_list, diff_time)
}
diff_time_list_int <- floor(diff_time_list)
#put in the data frame to show table
number_emb = seq(1,emb_num_plot)
embolism_time <- date_time_list[emb_img_idx_plot]
diff_time_list_tp <- diff_time_list_int[emb_img_idx_plot]
embolism_table <-  data.frame(embolism_time,diff_time_list_tp,number_emb)
colnames(embolism_table) <- c('embolism_time','time_since_start(mins)','number_emb')
```
#merge the two dataframes togther 
```{r merge_df}
plot_mat_time <- merge(plot_mat_all,embolism_table, by.x= 'Z', by.y= 'number_emb',all.x = TRUE)#5 cols: Z,row,col,embolism_time, time_since_start(mins)
```

```{r save_csv}
#Transform into csv format
#[Diane]
if(!file.exists(output_dir)){
  dir.create(output_dir)
}
if(!file.exists(file.path(output_dir,version_name))){
  dir.create(file.path(output_dir,version_name))
}
if (!file.exists(file.path(output_dir,version_name,folder_name_short))){
    dir.create(file.path(output_dir,version_name,folder_name_short))
}
write.csv2(plot_mat_time,file = file.path(output_dir,version_name,folder_name_short,'emb_points_time.csv'),row.names = TRUE)
```

#NO need to run if its just get the csv, need to run it for shiny app
```{r shiny_data}
#data to feed image to plot
sum_tiff <- array(rep(0,row_num*col_num),dim = c(row_num,col_num))
plot_tiff <- array(rep(0, row_num*col_num*emb_num_plot), dim=c(row_num, col_num, emb_num_plot))
i = 1
for (number in emb_img_idx_plot) {
  sum_tiff <- sum_tiff + pred_tiff[,,number]
  sum_tiff <- abs(sum_tiff -1)
  #make the mat sparse to easy plot
  plot_tiff[,,i] <- sum_tiff
  i = i+1
}

#save the data needed in shiny app
save(num_imgs,row_num,col_num,date_time_list, diff_time_list_int, embolism_table,  plot_mat_all, plot_tiff,  file = file.path(output_dir,version_name,folder_name_short,'shinydata.RData'))
```



